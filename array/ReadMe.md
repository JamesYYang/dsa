Array
==

数组是最基本的数据结构，它将元素存储在连续的内存位置。 这也是面试官的一个主要话题，你会在任何编码面试中听到很多关于数组的问题，例如： 反转数组，排序数组或搜索数组上的元素。

数组可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，时间复杂度可以到O(1)。但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)，因为一旦创建了数组，就无法更改数组的大小，要修改数组的长度，需要创建一个新数组并将所有元素从旧复制到新。

解决基于数组的问题的关键是熟悉数组数据结构以及基本编程构造函数，如循环，递归和基本运算符。

思考一个小问题：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

```
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：
```
a[k]_address = base_address + (k-1)*type_size
```
对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

好的，理论就讲到这，下面我们来”刷题“吧。

### 找到缺失的数字

题目：有一个整数（1~100）的数组，找到其中缺失的数字。

例如：数组为[1, 2, 3, 4, 6]，数组长度为6，那么缺失的数字应该是：5。

怎么样？简单吧。

什么方法最快？假如只有一个缺失的数字，那么求和最快了，因为我们知道，从1开始的n个正整数的和为：n (n+1) / 2。然后减去数组数字的总和，就知道缺失的数字了。

但是，如果这个数组中缺失的数字有多个呢？

请自行思考一下哈，然后我给了一个[可能的解决方案。](./find-missing-number.js)


### 去除数组中的重复数字

题目：给定一个数组，在不适用任何第三方类库的情况下，去除重复数字。

例如：输入 [1, 1, 2, 2, 5, 4, 3]，输出[1, 2, 3, 4, 5]。

这个题目也简单哈，主要是考虑如何找到重复的问题。

你可以自己思考一下哈，然后写一下代码。

我这里给了一个[参考解答](./remove-duplicate.js)


### 找到给定数组中最大和最小值

题目：给定一个数组，找到数组中最大和最小的数字。

例如：输入 [1, 20, 35, 14, -3]，输出：最大值 35，最小值 -3。

这个题目也简单哈，你可以自己思考一下哈，然后写一下代码。

我这里给了一个[参考解答](./max-min-array.js)


### 找到两个数字总和等于给定值

题目：编写一个程序来查找数组中的两个数字使得他们的和等于给定值。

例如：给定数组：[2, 4, 3, 5, 7, 8, 9]，给定值：7

输出：2和5，4和3。

这个题看似很简单，但是可以讨论的话题还不少。

第一个想法就是循环。双层循环对吧？大概的代码如下：

```js
for (let i = 0; i < numbers.length; i++) {
    let first = numbers[i];
    for (let j = i + 1; j < numbers.length; j++) {
      let second = numbers[j];
      if (first + second === n) {
        console.log(`(${first}, ${second})`);
      }
    }
  }
```

但是，这样的时间复杂度是很高的，达到了O(n^2)，还可以优化吗？

这个时候我们可能可以考虑去掉内层循环，使用哈希表嘛，这样就没必要每次去遍历了。大概的代码如下：

```js
let map = new Map();
numbers.forEach(item => {
  let target = n - item;
 
  if(!map.has(target)){
    map.set(item, '');
  }else{
    console.log(`(${item}, ${target})`);
  }
})
```

这样算下来，时间复杂度降到了O(n)，但是空间复杂度上来了，我们需要额外的存储空间，如果数组比较大，那么内存开销还是很大的。

我们还有没有其他优化？

更有效的就地解决方案是对数组进行排序，并使用两个指针从两个方向（即开始和结束）扫描数组。

如果两个值的总和等于给定数，那么我们输出该对并推进它们。 如果两个数之和小于k，那么我们增加左指针，否则如果总和大于k，我们递减右指针，直到两个指针在数组的某个部分相遇。

由于排序，该解决方案的复杂性将是O(nlogn)。

大概的代码如下：

```js
numbers.sort();
let left = 0;
let right = numbers.length - 1;
while(left < right){
  let sum = numbers[left] + numbers[right];
  if(sum === n){
    console.log(`(${numbers[left]}, ${numbers[right]})`);
    left = left + 1;
    right = right - 1;
  }else if(sum < n){
    left = left + 1;
  }else if(sum > n){
    right = right - 1;
  }
}
```

[完整的代码](./find-pairs.js)


### 找出数组中第一个未重复的数字

题目：编写一个程序来查找数组中第一个未重复出现过的数字。

例如：给定数组：[2, 4, 2, 3, 7, 3, 9]

输出：4

这个题目第一个想到的解法可能就是遍历数组，然后用一个哈希表来保存每个数字出现的次数，最后重哈希表中找到第一个计数为1的值即可。

可能的代码如下：

```js

//使用Map来保存每个数字的计数
  let counts = new Map();
  numbers.forEach(n => {
    counts.set(n, counts.has(n) ? counts.get(n) + 1 : 1);
  })
 
 
  //遍历Map，取第一个计数为1的数字
  for (let [key, value] of counts.entries()) {
    if (value === 1) {
      return key;
    }
  }
```

当然我们还可以优化一下。

第一种解法需要两次遍历，我们期望只遍历一次（O(n)），然后就直接可以找到这个数字。

我们可以用两个集合，一个保存重复过的数字，一个保存没有重复出现过的数字即可。可能的代码如下：

```js
let repeated = new Set();//保存重复出现过的数字
let nonRepeated = new Set();//保存未出现过的数字
 
  numbers.forEach(n => {
    if (!repeated.has(n)) {
      if (nonRepeated.has(n)) {
        nonRepeated.delete(n);
        repeated.add(n);
      } else {
        nonRepeated.add(n);
      }
    }
  })
  return nonRepeated.keys().next().value;
```

所以，算法就是空间和时间的平衡呀！

[完整代码](./find-first-non-repeat.js)